#' Fitting Linear Models
#'
#' lr is a custom function designed to fit linear models. It works for both simple linear regression and multiple
#' linear regression and generates the same results as lm function from R.
#'
#' @param formula an object of class "formula" with the form of response ~ predictors
#' @param source a data frame containing tha variables in the formula (model)
#' @param intercept an indicator for determining whether the model should be fit with or without intercept.The
#' default value of intercept is TRUE
#'
#' @return a list that contains the attributes of the fitted model. All of the attributes can be accessed by $.
#'
#' @examples
#' lr(mpg ~ hp + wt, mtcars)
#' fitted_model <- lr(mpg ~ hp + wt, mtcars)
#' fitted_model$r_square
#'
#' @export
#'

lr <- function(formula, source, intercept=TRUE) {
  # remove NA rows
  source = na.omit(source)
  # get all Xs
  predictors = labels(terms(formula))
  # check existence of all Xs
  for (str in strsplit(predictors, " ")) {
    if (!str %in% names(source)) {
      stop(str, " is not a valid column!")
    }
  }
  # build matrix for Xs
  X = as.matrix(source[predictors], nrow(source), len(predictors))
  # build matrix for Y
  targets = as.character(formula[[2]])
  Y = as.matrix(source[targets], nrow(source), 1)

  if (intercept) {
    X = cbind(rep(1, nrow(source)), X)
  }
  # solve equations for coefficients
  a = t(X) %*% X
  b = t(X) %*% Y
  coeff = t(solve(a, b))

  # re-name every property
  rownames(coeff) = c("")
  if (intercept) {
    colnames(coeff) = c("(Intercept)", predictors)
  } else {
    colnames(coeff) = predictors
  }

  # calculate predicated Ys
  Y_pred = X %*% t(coeff)
  residuals = Y - Y_pred
  # built residual stats
  residual_matrix = matrix(c(min(residuals), quantile(residuals, 0.25),
                             median(residuals), quantile(residuals, 0.75),
                             max(residuals)), nrow = 1, ncol = 5)
  rownames(residual_matrix) = c(" ")
  colnames(residual_matrix) = c("Min", "1Q", "Median", "3Q", "Max")

  k = ncol(X)
  # solve for R-squared and adjusted R-squared
  SSE = sum((Y - Y_pred) ^ 2)
  SST = sum((Y - mean(Y)) ^ 2)
  SSR = sum((Y_pred - mean(Y)) ^ 2)
  R_square = 1 - (SSE / SST)
  adjusted_R_square = 1 - ((1 - R_square) * (nrow(source) - 1) / (nrow(source) - k))


  # solve for f-statistic
  MSR = SSR / (k - 1)
  MSE = SSE / (nrow(source) - k)
  f_static = MSR / MSE
  p_val_f_static = pf(f_static, length(predictors), (nrow(source) - k), lower.tail = FALSE)

  # solve for std.error
  var = solve(a, diag(MSE, k, k), transpose = FALSE)
  std_err = sqrt(diag(var))
  t_value = coeff / std_err
  p_val_t_value = 2 * pt(-abs(t_value), nrow(source) - k)
  std_err = t(matrix(std_err))
  rownames(std_err) = c(" ")
  colnames(std_err) = c("(Intercept)", predictors)

  cat("\nCall:\n")
  formula_str = as.character(formula)
  cat(" lr(formula =", formula_str[[2]], formula_str[[1]], paste0(formula_str[[3]], ")\n\n"))
  cat("\nCoefficients:\n")
  print(coeff)
  cat("\n")


  # return all the results within a list
  return(invisible(list(coefficients = coeff,
                        call = formula,
                        residuals = residual_matrix,
                        r_square = R_square,
                        adjusted_R_square = adjusted_R_square,
                        std_err = std_err,
                        t_value = t_value,
                        p_val_t_value = p_val_t_value,
                        f_static = f_static,
                        p_val_f_static = p_val_f_static,
                        predictors = predictors,
                        samples = nrow(source),
                        intercept = intercept)))
}

#' Display the summary of a lr model
#'
#' summary_lr function organizes and outputs each attribute of a lr model in the similar format as summary function
#' in R.
#'
#' @param lr_model A linear regression model generated by the lr function
#'
#' @examples
#' fitted_model <- lr(mpg ~ hp + wt, mtcars)
#' summary_lr(fitted_model)
#'
#' @export
#'

summary_lr <- function(lr_model) {
  # print the formula
  cat("\nCall:\n")
  formula_str = as.character(lr_model$call)
  cat(" lr(formula =", formula_str[[2]], formula_str[[1]], paste0(formula_str[[3]], ")\n\n"))
  # print the residual stats
  cat("Residuals:\n")
  lr_model$residuals = round(lr_model$residuals, 4)
  print(lr_model$residuals)
  # print the coefficients
  cat("\nCoefficients:\n")
  coefficients_df = data.frame(list(t(lr_model$coefficients), t(lr_model$std_err), t(lr_model$t_value), t(lr_model$p_val_t_value)))
  colnames(coefficients_df) = c("Estimate", "Std.Error", "t value", "Pr(>|t|)")
  coefficients_df = round(coefficients_df, 4)
  print(coefficients_df)
  DF = lr_model$samples - length(lr_model$predictor)
  # print r_squared and f_statistic
  if (lr_model$intercept) {
    DF = DF - 1
  }
  cat("\nMultiple R-squared:", paste0(round(lr_model$r_square, 4), ", "), "Adjusted R-squared: ", round(lr_model$adjusted_R_square, 4), "\n")
  cat("F-statistic: ", round(lr_model$f_static, 2), "on", length(lr_model$predictor), "and",
      DF, "DF, ", "p-value: ", lr_model$p_val_f_static, "\n\n")
}

#' Model Predictions
#'
#' Predict the value based on the input data and trained linear regression model.
#'
#' @param lr_model A linear regression model generated by the lr function
#' @param new_data A R data frame that contains
#'
#' @examples
#' fitted_model <- lr(mpg ~ hp + wt, mtcars)
#' new_data <- data.frame(hp = c(110), wt = c(3.521)
#' prediction(fitted_model, new_data)
#'
#' @export
#'

prediction <- function(lr_model, new_data) {
  # intercept is enabled
  X = matrix()
  if (lr_model$intercept) {
    # insert the intercept column
    new_data = cbind(rep(1, nrow(new_data)), new_data)
    X = as.matrix(new_data, 1, length(lr_model$predictor) + 1)
  } else {
    X = as.matrix(new_data, 1, length(lr_model$predictor))
  }
  pred = X %*% t(lr_model$coefficients)
  print(t(pred))
}


