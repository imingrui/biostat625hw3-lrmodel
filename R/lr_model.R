#' Fitting Linear Models
#'
#' *lr* is a custom function designed to fit linear models. It works for both simple linear regression and multiple
#' linear regression and generates numeric attributes of the fitted model
#'
#' @param formula an object of class "formula" with the form of response ~ predictors
#' @param source a data frame containing all the variables in the formula
#'
#' @return Returns a list containing the following attributes of the fitted model.
#' * coefficients, a vector of coefficients
#' * call, the matched call
#' * residuals, a matrix of residuals
#' * r_square, R squared value
#' * adjusted_R_square, adjusted R squared value
#' * std_err, standard error
#' * t_value, T value
#' * P_val_t_value, P Value of T value
#' * f_static, F-statistic
#' * p_val_f_static, P value of F-statistic
#' * predictors, names of all predictors
#' * samples, number of samples being used
#'
#' @examples
#'
#' ## run and find a fitted model
#' lr(mpg ~ hp + wt, mtcars)
#' fitted_model <- lr(mpg ~ hp + wt, mtcars)
#'
#' ## access the R squared value of the fitted model
#' fitted_model$r_square
#'
#' @export
#'

lr <- function(formula, source) {
  # remove NA rows
  source = na.omit(source)
  # get all Xs
  predictors = labels(terms(formula))
  # check existence of all Xs
  for (str in strsplit(predictors, " ")) {
    if (!str %in% names(source)) {
      stop(str, " is not a valid column!")
    }
  }
  # build matrix for Xs
  X = as.matrix(source[predictors], nrow(source), len(predictors))
  # build matrix for Y
  targets = as.character(formula[[2]])
  Y = as.matrix(source[targets], nrow(source), 1)
  X = cbind(rep(1, nrow(source)), X)
  # solve equations for coefficients
  a = t(X) %*% X
  b = t(X) %*% Y
  coeff = t(solve(a, b))

  # re-name every property
  rownames(coeff) = c("")
  colnames(coeff) = c("(Intercept)", predictors)

  # calculate predicated Ys
  Y_pred = X %*% t(coeff)
  residuals = Y - Y_pred
  # built residual stats
  residual_matrix = matrix(c(min(residuals), quantile(residuals, 0.25),
                             median(residuals), quantile(residuals, 0.75),
                             max(residuals)), nrow = 1, ncol = 5)
  rownames(residual_matrix) = c(" ")
  colnames(residual_matrix) = c("Min", "1Q", "Median", "3Q", "Max")

  k = ncol(X)
  # solve for R-squared and adjusted R-squared
  SSE = sum((Y - Y_pred) ^ 2)
  SST = sum((Y - mean(Y)) ^ 2)
  SSR = sum((Y_pred - mean(Y)) ^ 2)
  R_square = 1 - (SSE / SST)
  adjusted_R_square = 1 - ((1 - R_square) * (nrow(source) - 1) / (nrow(source) - k))


  # solve for f-statistic
  MSR = SSR / (k - 1)
  MSE = SSE / (nrow(source) - k)
  f_static = MSR / MSE
  p_val_f_static = pf(f_static, length(predictors), (nrow(source) - k), lower.tail = FALSE)

  # solve for std.error
  var = solve(a, diag(MSE, k, k), transpose = FALSE)
  std_err = sqrt(diag(var))
  t_value = coeff / std_err
  p_val_t_value = 2 * pt(-abs(t_value), nrow(source) - k)
  std_err = t(matrix(std_err))
  rownames(std_err) = c(" ")
  colnames(std_err) = c("(Intercept)", predictors)

  cat("\nCall:\n")
  formula_str = as.character(formula)
  cat(" lr(formula =", formula_str[[2]], formula_str[[1]], paste0(formula_str[[3]], ")\n\n"))
  cat("\nCoefficients:\n")
  print(coeff)
  cat("\n")


  # return all the results within a list
  return(invisible(list(coefficients = coeff,
                        call = formula,
                        residuals = residual_matrix,
                        r_square = R_square,
                        adjusted_R_square = adjusted_R_square,
                        std_err = std_err,
                        t_value = t_value,
                        p_val_t_value = p_val_t_value,
                        f_static = f_static,
                        p_val_f_static = p_val_f_static,
                        predictors = predictors,
                        samples = nrow(source))))
}

#' Display the summary of a lr model
#'
#' *summary_lr* function organizes and outputs all attributes of a lr model in the similar format as *summary* function
#' does.
#'
#' @param lr_model  a linear regression model generated by *lr* function
#'
#' @examples
#' fitted_model <- lr(mpg ~ hp + wt, mtcars)
#' summary_lr(fitted_model)
#'
#' @export
#'

summary_lr <- function(lr_model) {
  # print the formula
  cat("\nCall:\n")
  formula_str = as.character(lr_model$call)
  cat(" lr(formula =", formula_str[[2]], formula_str[[1]], paste0(formula_str[[3]], ")\n\n"))
  # print the residual stats
  cat("Residuals:\n")
  lr_model$residuals = round(lr_model$residuals, 4)
  print(lr_model$residuals)
  # print the coefficients
  cat("\nCoefficients:\n")
  coefficients_df = data.frame(list(t(lr_model$coefficients), t(lr_model$std_err), t(lr_model$t_value), t(lr_model$p_val_t_value)))
  colnames(coefficients_df) = c("Estimate", "Std.Error", "t value", "Pr(>|t|)")
  coefficients_df = round(coefficients_df, 4)
  print(coefficients_df)
  DF = lr_model$samples - length(lr_model$predictor)
  # print r_squared and f_statistic
  if (lr_model$intercept) {
    DF = DF - 1
  }
  cat("\nMultiple R-squared:", paste0(round(lr_model$r_square, 4), ", "), "Adjusted R-squared: ", round(lr_model$adjusted_R_square, 4), "\n")
  cat("F-statistic: ", round(lr_model$f_static, 2), "on", length(lr_model$predictor), "and",
      DF, "DF, ", "p-value: ", lr_model$p_val_f_static, "\n\n")
}

#' Model Prediction
#'
#' Predict the value based on the input data and a trained lr model
#'
#' @param lr_model a linear regression model generated by *lr* function
#' @param new_data a data frame containing all the variables in the model
#'
#' @examples
#' fitted_model <- lr(mpg ~ hp + wt, mtcars)
#' new_data <- data.frame(hp = c(110), wt = c(3.521))
#' p <- prediction(fitted_model, new_data)
#'
#' @return Returns the predicted values
#'
#' @export
#'

prediction <- function(lr_model, new_data) {
  # intercept is enabled
  X = matrix()
  # insert the intercept column
  new_data = cbind(rep(1, nrow(new_data)), new_data)
  X = as.matrix(new_data, 1, length(lr_model$predictor) + 1)
  pred = X %*% t(lr_model$coefficients)
  return(t(pred))
}


